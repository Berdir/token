<?php
// $Id$

/**
 * Implement hook_menu().
 */
function token_menu() {
  $items['admin/settings/token'] = array(
    'title' => 'Token testing',
    'description' => "Test replacement tokens in real time.",
    'page callback' => 'drupal_get_form',
    'page arguments' => array('token_test_form'),
    'access arguments' => array('administer site'),
    'file' => 'token.dev.inc',
  );
  return $items;
}

/**
 * Find all tokens in a given string and replace them with appropriate values.
 *
 * @param $text
 *   The text containing replacable tokens.
 * @param $data
 *   An array of keyed objects. For simple replacement scenarios 'node', 'user',
 *   and others are common keys, with an accompanying node or user object being
 *   the value. Some tokens types, like 'site', do not require any explicit
 *   information from $data and can be replaced even if $data is empty.
 * @returns
 *   Text with tokens replaced.
 */
function token_replace($text, array $data = array()) {
  $token_list = token_scan($text);
  $replacements = token_generate($token_list, $data, TRUE);
  
  $tokens = array_keys($replacements);
  $values = array_values($replacements);
  
  return str_replace($tokens, $values, $text);
}

/**
 * Build a list of all token-like patterns that appear in the text.
 *
 * @param $text
 *   The text to be scanned for possible tokens.
 * @returns
 *   An associative array of discovered tokens, grouped by type.
 */
function token_scan($text) {  
  preg_match_all('/\[([^\]:\ ]*):([^\]\ ]*)\]/', $text, $matches);

  $tokens = array();
  
  $raw = $matches[0];
  $type = $matches[1];
  $token = $matches[2];

  for ($i = 0; $i < count($raw); $i++) {
    $tokens[$type[$i]][$token[$i]] = $raw[$i];
  }
  
  return $tokens;
}

/**
 * Generate replacement values for a list of tokens.
 *
 * @param $raw_tokens
 *   A keyed array of tokens, and their original raw form in the source text.
 * @param $data
 *   An array of keyed objects. For simple replacement scenarios 'node', 'user',
 *   and others are common keys, with an accompanying node or user object being
 *   the value. Some tokens types, like 'site', do not require any explicit
 *   information from $data and can be replaced even if $data is empty.
 * @param $sanitize
 *   A boolean flag indicating whether the replacement values should be sanitized
 *   for display on an HTML page. Defaults to TRUE.
 * @returns
 *   An associative array of discovered tokens, grouped by type.
 */
function token_generate(array $raw_tokens, array $data = array(), $sanitize = TRUE) {
  $results = array();
  foreach ($raw_tokens as $type => $tokens) {
    foreach (module_invoke_all('tokens', $type, $tokens, $data, $sanitize) as $original => $replacement) {
      $results[$original] = $replacement;
    }
  }
  return $results;
}

/**
 * Given a list of tokens, return those that begin with a specific prefix.
 *
 * @param $tokens
 *   A keyed array of tokens, and their original raw form in the source text.
 * @param $prefix
 *   A textual string to be matched at the beginning of the token.
 * @param $delimiter
 *   An optional string containing the character that separates the prefix from
 *   the rest of the token. Defaults to ':'.
 * @returns
 *   An associative array of discovered tokens, with the prefix and delimiter
 *   stripped from the key.
 */
function token_match_prefix(array $tokens, $prefix, $delimiter = ':') {
  $results = array();
  foreach ($tokens as $token => $raw) {
    $parts = split($delimiter, $token, 2);
    if (count($parts) == 2 && $parts[0] == $prefix) {
      $results[$parts[1]] = $raw;
    }
  }
  return $results;
}

/**
 * Returns metadata describing supported tokens.
 *
 * The metadata array contains token type, name, and description data as well as
 * an optional pointer indicating that the token chains to another set of tokens.
 * For example:
 *
 *   $data['types']['node'] = array(
 *     'name' => t('Nodes'),
 *     'description' => t('Tokens related to node objects.'),
 *   );
 *   $data['tokens']['node']['title'] = array(
 *     'name' => t('Title'),
 *     'description' => t('The title of the current node.'),
 *   );
 *   $data['tokens']['node']['author'] = array(
 *     'name' => t('Author'),
 *     'description' => t('The author of the current node.'),
 *     'references' => 'user',
 *   );
 *
 * @param $reset
 *   Rebuild the internal cache of Token metadata. Defaults to FALSE.
 * @returns
 *   An associative array of token information, grouped by token type.
 */
function token_info($reset = FALSE) {
  $data = &drupal_static(__FUNCTION__, array(), $reset);
  if (empty($data)) {
    $data = module_invoke_all('token_info');
    drupal_alter('token_info', $data);
  }
  return $data;
}

/*
 * Implement hook_registry_files_alter().
 *
 * The files in Token module's /modules directory implement hooks on behalf
 * of other modules. This hook iterates through them and switches the 'owning'
 * module from token to the real one.
 *
 * We loves us drupal_alter().
 */
function token_registry_files_alter(&$files, $modules) {
  $dir = $modules['token']->dir;
  foreach ($modules['token']->info['files'] as $file) {
    $path = split('/', $file);
    $inc_file = array_pop($path);
    $pieces = explode('.', $inc_file, 2);
    if ($pieces[1] == 'tokens.inc') {
      $files["$dir/$file"]['module'] = $pieces[0];
    }
  }
}