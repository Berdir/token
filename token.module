<?php
// $Id$

/**
 * Implements hook_menu().
 */
function token_menu() {
  $items['token/autocomplete'] = array(
    'page callback' => 'token_autocomplete',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
    'file' => 'token.pages.inc',
  );
  return $items;
}

/**
 * Implements hook_theme().
 */
function token_theme() {
  return array(
    'token_tree' => array(
      'variables' => array('token_types' => array(), 'global_types' => TRUE, 'click_insert' => TRUE, 'recursion_limit' => 4),
      'file' => 'token.pages.inc',
    ),
  );
}

/**
 * Implements hook_library().
 */
function token_library() {
  // jQuery treeTable plugin.
  $libraries['treeTable'] = array(
    'title' => 'jQuery treeTable',
    'website' => 'http://plugins.jquery.com/project/treetable',
    'version' => '2.3.0',
    'js' => array(
      drupal_get_path('module', 'token') . '/jquery.treeTable.js' => array(),
    ),
    'css' => array(
      drupal_get_path('module', 'token') . '/jquery.treeTable.css' => array(),
    ),
  );

  return $libraries;
}

/**
 * Get a list of token types that can be used without any context (global).
 *
 * @return
 *   An array of global token types.
 */
function token_get_global_token_types() {
  $global_types = &drupal_static(__FUNCTION__, array());
  $token_info = token_info();

  // Add the token types that are always valid in global context.
  foreach ($token_info['types'] as $type => $type_info) {
    if (empty($type_info['needs-data'])) {
      $global_types[] = $type;
    }
  }

  return $global_types;
}

/**
 * Validate an tokens in raw text based on possible contexts.
 *
 * @param $text
 *   A string with the raw text containing the raw tokens.
 * @param $tokens
 *   An array of token types that will be used when token replacement is
 *   performed.
 * @return
 *   An array with the invalid tokens in their original raw forms.
 */
function token_get_invalid_tokens_by_context($text, $valid_types = array()) {
  $token_info = token_info();

  // Add the token types that are always valid in global context.
  foreach ($token_info['types'] as $type => $type_info) {
    if (empty($type_info['needs-data']) && !in_array($type, $valid_types)) {
      $valid_types[] = $type;
    }
  }

  $invalid_tokens = array();
  foreach (token_scan($text) as $type => $tokens) {
    if (!in_array($type, $valid_types)) {
      // If the token type is not a valid context, its tokens are invalid.
      $invalid_tokens = array_merge($invalid_tokens, array_values($tokens));
    }
    else {
      // Check each individual token for validity.
      $invalid_tokens = array_merge($invalid_tokens, token_get_invalid_tokens($type, $tokens));
    }
  }

  return $invalid_tokens;
}

/**
 * Validate an array of tokens based on their token type.
 *
 * @param $type
 *   The type of tokens to validate (e.g. 'node', etc.)
 * @param $tokens
 *   A keyed array of tokens, and their original raw form in the source text.
 * @return
 *   An array with the invalid tokens in their original raw forms.
 */
function token_get_invalid_tokens($type, $tokens) {
  $token_info = token_info();
  $invalid_tokens = array();

  foreach ($tokens as $token => $full_token) {
    // Split token up if it has chains.
    $parts = explode(':', $token, 2);

    if (!isset($token_info['tokens'][$type][$parts[0]])) {
      // This is an invalid token (not defined).
      $invalid_tokens[] = $full_token;
    }
    elseif (count($parts) == 2) {
      $sub_token_info = $token_info['tokens'][$type][$parts[0]];
      if (!empty($sub_token_info['dynamic'])) {
        // If this token has been flagged as a dynamic token, skip it.
        continue;
      }
      elseif (empty($sub_token_info['type'])) {
        // If the token has chains, but does not support it, it is invalid.
        $invalid_tokens[] = $full_token;
      }
      else {
        // Resursively check the chained tokens.
        $sub_tokens = token_find_with_prefix(array($token => $full_token), $parts[0]);
        $invalid_tokens = array_merge($invalid_tokens, token_get_invalid_tokens($sub_token_info['type'], $sub_tokens));
      }
    }
  }

  return $invalid_tokens;
}
