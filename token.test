<?php
// $Id$

/**
 * Helper test class with some added functions for testing.
 */
class TokenTestHelper extends DrupalWebTestCase {
  function setUp() {
    $args = func_get_args();

    // Call parent::setUp() allowing test cases to pass further modules.
    $modules = array('path', 'token');
    if (isset($args[0]) && is_array($args[0])) {
      $modules = array_merge($modules, $args[0]);
    }
    parent::setUp($modules);
  }

  function assertToken($type, $object, $token, $expected, array $options = array()) {
    $this->assertTokens($type, $object, array($token => $expected), $options);
  }

  function assertTokens($type, $object, array $tokens, array $options = array()) {
    $token_input = drupal_map_assoc(array_keys($tokens));
    $values = token_generate($type, $token_input, array($type => $object), $options);
    foreach ($tokens as $token => $expected) {
      $this->assertIdentical($values[$token], $expected, t("Token value for [@type:@token] was '@actual', expected value '@expected'.", array('@type' => $type, '@token' => $token, '@actual' => $values[$token], '@expected' => $expected)));
    }
  }

  function saveAlias($source, $alias, $language = LANGUAGE_NONE) {
    $alias = array(
      'source' => $source,
      'alias' => $alias,
      'language' => $language,
    );
    path_save($alias);
    return $alias;
  }

  function saveEntityAlias($entity_type, $entity, $alias, $language = LANGUAGE_NONE) {
    $uri = entity_uri($entity_type, $entity);
    return $this->saveAlias($uri['path'], $alias, $language);
  }
}

class TokenUnitTestCase extends TokenTestHelper {
  public static function getInfo() {
    return array(
      'name' => 'Token unit tests',
      'description' => 'Test basic, low-level token functions.',
      'group' => 'Token',
    );
  }

  /**
   * Test token_get_invalid_tokens() and token_get_invalid_tokens_by_context().
   */
  public function testGetInvalidTokens() {
    $tests = array();
    $tests[] = array(
      'valid tokens' => array(
        '[node:title]',
        '[node:created:short]',
        '[node:created:custom:invalid]',
        '[node:created:custom:mm-YYYY]',
        '[site:name]',
        '[site:slogan]',
      ),
      'invalid tokens' => array(
        '[node:title:invalid]',
        '[node:created:invalid]',
        '[node:created:short:invalid]',
        '[invalid:title]',
        '[site:invalid]',
      ),
      'types' => array('node'),
    );

    foreach ($tests as $test) {
      $tokens = array_merge($test['valid tokens'], $test['invalid tokens']);
      shuffle($tokens);

      $invalid_tokens = token_get_invalid_tokens_by_context(implode(' ', $tokens), $test['types']);

      sort($invalid_tokens);
      sort($test['invalid tokens']);
      $this->assertEqual($invalid_tokens, $test['invalid tokens'], 'Invalid tokens detected properly.');
    }
  }
}

class TokenNodeTestCase extends TokenTestHelper {
  public static function getInfo() {
    return array(
      'name' => 'Node token tests',
      'description' => 'Test the node tokens.',
      'group' => 'Token',
    );
  }

  function testNodeTokens() {
    $source_node = $this->drupalCreateNode(array('log' => $this->randomName(), 'path' => array('alias' => 'content/source-node')));
    $translated_node = $this->drupalCreateNode(array('tnid' => $source_node->nid));

    // Test [node:source] tokens.
    $this->assertToken('node', $translated_node, 'source', $source_node->title);
    $this->assertToken('node', $translated_node, 'source:nid', $source_node->nid);
    //$this->assertToken('node', $source_node, 'source', '', array('clear' => TRUE));

    // Test [node:log] token.
    $this->assertToken('node', $source_node, 'log', $source_node->log);
    $this->assertToken('node', $translated_node, 'log', '');

    // Test [node:path] token.
    $this->assertToken('node', $source_node, 'path', 'content/source-node');
    $this->assertToken('node', $translated_node, 'path', 'node/' . $translated_node->nid);
  }
}

class TokenMenuTestCase extends TokenTestHelper {
  public static function getInfo() {
    return array(
      'name' => 'Menu token tests',
      'description' => 'Test the menu tokens.',
      'group' => 'Token',
    );
  }

  function setUp() {
    parent::setUp(array('menu'));
  }

  function testMenuTokens() {
    $root_link = array(
      'link_path' => '<front>',
      'link_title' => 'Front link',
      'menu_name' => 'main-menu',
    );
    menu_link_save($root_link);

    $node_link = array(
      'enabled' => TRUE,
      'link_title' => 'Node link',
      'plid' => $root_link['mlid'],
      'customized' => 0,
      'description' => '',
    );
    $node = $this->drupalCreateNode(array('menu' => $node_link));

    // Test [node:menu] tokens.
    $tokens = array(
      'menu-link' => 'Node link',
      'menu-link:mlid' => $node->menu['mlid'],
      'menu-link:title' => 'Node link',
      'menu-link:menu' => 'main-menu',
      'menu-link:menu-name' => 'Main menu',
      'menu-link:path' => 'node/' . $node->nid,
      'menu-link:url' => url('node/' . $node->nid, array('absolute' => TRUE)),
      'menu-link:parent' => 'Front link',
      'menu-link:parent:mlid' => $node->menu['plid'],
      'menu-link:parent:mlid' => $root_link['mlid'],
    );
    $this->assertTokens('node', $node, $tokens);
  }
}

class TokenTaxonomyTestCase extends TokenTestHelper {
  protected $vocab;

  public static function getInfo() {
    return array(
      'name' => 'Taxonomy and vocabulary token tests',
      'description' => 'Test the taxonomy tokens.',
      'group' => 'Token',
    );
  }

  function setUp() {
    parent::setUp(array('taxonomy'));
    // Use the default 'Tags' taxonomy included with the standard install profile.
    $this->vocab = taxonomy_vocabulary_machine_name_load('tags');
  }

  /**
   * Test the additional taxonomy term tokens.
   */
  function testTaxonomyTokens() {
    $parent_term = $this->addTerm($this->vocab, array('path' => array('alias' => 'parent-term')));
    $parent_term_tokens = array(
      'path' => 'parent-term',
      'edit-url' => url("taxonomy/term/{$parent_term->tid}/edit", array('absolute' => TRUE)),
    );
    $this->assertTokens('term', $parent_term, $parent_term_tokens);

    $child_term = $this->addTerm($this->vocab, array('parent' => $parent_term->tid));
    $child_term_tokens = array(
      'path' => "taxonomy/term/{$child_term->tid}",
      'edit-url' => url("taxonomy/term/{$child_term->tid}/edit", array('absolute' => TRUE)),
    );
    $this->assertTokens('term', $child_term, $child_term_tokens);
  }

  /**
   * Test the additional vocabulary tokens.
   */
  function testVocabularyTokens() {
    $vocabulary = $this->vocab;
    $tokens = array(
      'machine-name' => 'tags',
      'edit-url' => url("admin/structure/taxonomy/{$vocabulary->machine_name}/edit", array('absolute' => TRUE)),
    );
    $this->assertTokens('vocabulary', $vocabulary, $tokens);
  }

  function addVocabulary(array $vocabulary = array()) {
    $vocabulary += array(
      'name' => drupal_strtolower($this->randomName(5)),
      'nodes' => array('article' => 'article'),
    );
    $vocabulary = (object) $vocabulary;
    taxonomy_vocabulary_save($vocabulary);
    return $vocabulary;
  }

  function addTerm(stdClass $vocabulary, array $term = array()) {
    $term += array(
      'name' => drupal_strtolower($this->randomName(5)),
      'vid' => $vocabulary->vid,
    );
    $term = (object) $term;
    taxonomy_term_save($term);
    return $term;
  }
}

class TokenEntityTestCase extends TokenTestHelper {
  public static function getInfo() {
    return array(
      'name' => 'Entity token tests',
      'description' => 'Test the entity tokens.',
      'group' => 'Token',
    );
  }

  function setUp() {
    parent::setUp(array('taxonomy'));
  }

  function testEntityMapping() {
    $this->assertIdentical(token_get_entity_mapping('token', 'node'), 'node');
    $this->assertIdentical(token_get_entity_mapping('token', 'term'), 'taxonomy_term');
    $this->assertIdentical(token_get_entity_mapping('token', 'vocabulary'), 'taxonomy_vocabulary');
    $this->assertIdentical(token_get_entity_mapping('token', 'invalid'), FALSE);
    $this->assertIdentical(token_get_entity_mapping('entity', 'node'), 'node');
    $this->assertIdentical(token_get_entity_mapping('entity', 'taxonomy_term'), 'term');
    $this->assertIdentical(token_get_entity_mapping('entity', 'taxonomy_vocabulary'), 'vocabulary');
    $this->assertIdentical(token_get_entity_mapping('entity', 'invalid'), FALSE);

    // Test that when we send the mis-matched entity type into token_replace()
    // that we still get the tokens replaced.
    $vocabulary = taxonomy_vocabulary_machine_name_load('tags');
    $term = $this->addTerm($vocabulary);
    $this->assertIdentical(token_replace('[vocabulary:name]', array('taxonomy_vocabulary' => $vocabulary)), $vocabulary->name);
    $this->assertIdentical(token_replace('[term:name][term:vocabulary:name]', array('taxonomy_term' => $term)), $term->name . $vocabulary->name);
  }

  function addTerm(stdClass $vocabulary, array $term = array()) {
    $term += array(
      'name' => drupal_strtolower($this->randomName(5)),
      'vid' => $vocabulary->vid,
    );
    $term = (object) $term;
    taxonomy_term_save($term);
    return $term;
  }
}
