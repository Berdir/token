<?php
// $Id$

/**
 * Implement hook_menu().
 */
function token_menu() {
  $items['admin/settings/token'] = array(
    'title' => 'Token testing',
    'description' => "Test replacement tokens in real time.",
    'page callback' => 'drupal_get_form',
    'page arguments' => array('token_test_form'),
    'access arguments' => array('administer site'),
    'file' => 'token.dev.inc',
  );
  return $items;
}

/**
 * Replace all tokens in a given string with appropriate values.
 *
 * @param $text
 *   A string potentially containing replacable tokens.
 * @param $data
 *   (optional) An array of keyed objects. For simple replacement scenarios
 *   'node', 'user', and others are common keys, with an accompanying node or
 *   user object being the value. Some token types, like 'site', do not require
 *   any explicit information from $data and can be replaced even if it is empty.
 * @param $options
 *   (optional) A keyed array of settings and flags to control the token
 *   replacement process. Supported options are:
 *   - language: A language object to be used when generating locale-sensitive
 *     tokens.
 *   - callback: A callback function that will be used to post-process the array
 *     of token replaements after they are generated. Can be used when modules
 *     require special formatting of token text, for example URL encoding or
 *     truncation to a specific length.
 *   - sanitize: A boolean flag indicating that tokens should be sanitized for
 *     display to a web browser. Developers who set this option to FALSE assume
 *     responsibility for running filter_xss(), check_plain() or other
 *     appropriate scrubbing functions before displaying data to users.
 * @return
 *   Text with tokens replaced.
 */
function token_replace($text, array $data = array(), array $options = array()) {
  $token_list = token_scan($text);
  $replacements = token_generate($token_list, $data, $options);

  if (!empty($options['callback']) && drupal_function_exists($options['callback'])) {
    $function = $options['callback'];
    $function($replacements, $data, $options);
  }

  $tokens = array_keys($replacements);
  $values = array_values($replacements);
  
  return str_replace($tokens, $values, $text);
}

/**
 * Build a list of all token-like patterns that appear in the text.
 *
 * @param $text
 *   The text to be scanned for possible tokens.
 * @return
 *   An associative array of discovered tokens, grouped by type.
 */
function token_scan($text) {
  // Matches tokens with the following pattern: [$type:$token]
  // $type and $token may not contain white spaces.
  preg_match_all('/\[([^\s\]:]*):([^\s\]]*)\]/', $text, $matches);

  $types = $matches[1];
  $tokens = $matches[2];

  // Iterate through the matches, building an associative array containing
  // $tokens grouped by $types, pointing to the version of the token found in
  // the source text. For example, $results['node']['title'] = '[node:title]';
  $results = array();
  for ($i = 0; $i < count($tokens); $i++) {
    $results[$types[$i]][$tokens[$i]] = $matches[0][$i];
  }

  return $results;
}

/**
 * Generate replacement values for a list of tokens.
 *
 * @param $raw_tokens
 *   A keyed array of tokens, and their original raw form in the source text.
 * @param $data
 *   (optional) An array of keyed objects. For simple replacement scenarios
 *   'node', 'user', and others are common keys, with an accompanying node or
 *   user object being the value. Some token types, like 'site', do not require
 *   any explicit information from $data and can be replaced even if it is empty.
 * @param $options
 *   (optional) A keyed array of settings and flags to control the token
 *   replacement process. Supported options are:
 *   - 'language' A language object to be used when generating locale-sensitive
 *     tokens.
 *   - 'callback' A callback function that will be used to post-process the array
 *     of token replaements after they are generated. Can be used when modules
 *     require special formatting of token text, for example URL encoding or
 *     truncation to a specific length.
 *   - 'sanitize' A boolean flag indicating that tokens should be sanitized for
 *     display to a web browser. Developers who set this option to FALSE assume
 *     responsibility for running filter_xss(), check_plain() or other
 *     appropriate scrubbing functions before displaying data to users.
 * @return
 *   An associative array of replacement values, keyed by the original 'raw'
 *   tokens that were found in the source text. For example:
 *   $results['[node:title]'] = 'My new node';
 */
function token_generate(array $raw_tokens, array $data = array(), array $options = array()) {
  $results = array();
  $options += array('sanitize' => TRUE);

  foreach ($raw_tokens as $type => $tokens) {
    foreach (module_invoke_all('tokens', $type, $tokens, $data, $options) as $original => $replacement) {
      $results[$original] = $replacement;
    }
  }
  return $results;
}

/**
 * Given a list of tokens, return those that begin with a specific prefix.
 *
 * Used to extract a group of 'chained' tokens (such as [node:author:name]) from
 * the full list of tokens found in text. For example:
 * @code
 *   $data = array(
 *     'author:name' => '[node:author:name]',
 *     'title'       => '[node:title]',
 *     'created'     => '[node:author:name]',
 *   );
 *   $results = token_find_with_prefix($data, 'author');
 *   $results == array('name' => '[node:author:name]');
 * @endcode
 *
 * @param $tokens
 *   A keyed array of tokens, and their original raw form in the source text.
 * @param $prefix
 *   A textual string to be matched at the beginning of the token.
 * @param $delimiter
 *   An optional string containing the character that separates the prefix from
 *   the rest of the token. Defaults to ':'.
 * @return
 *   An associative array of discovered tokens, with the prefix and delimiter
 *   stripped from the key.
 */
function token_find_with_prefix(array $tokens, $prefix, $delimiter = ':') {
  $results = array();
  foreach ($tokens as $token => $raw) {
    $parts = split($delimiter, $token, 2);
    if (count($parts) == 2 && $parts[0] == $prefix) {
      $results[$parts[1]] = $raw;
    }
  }
  return $results;
}

/**
 * Returns metadata describing supported tokens.
 *
 * The metadata array contains token type, name, and description data as well as
 * an optional pointer indicating that the token chains to another set of tokens.
 * For example:
 * @code
 *   $data['types']['node'] = array(
 *     'name' => t('Nodes'),
 *     'description' => t('Tokens related to node objects.'),
 *   );
 *   $data['tokens']['node']['title'] = array(
 *     'name' => t('Title'),
 *     'description' => t('The title of the current node.'),
 *   );
 *   $data['tokens']['node']['author'] = array(
 *     'name' => t('Author'),
 *     'description' => t('The author of the current node.'),
 *     'type' => 'user',
 *   );
 * @endcode
 * @return
 *   An associative array of token information, grouped by token type.
 */
function token_info() {
  $data = &drupal_static(__FUNCTION__);
  if (!isset($data)) {
    $data = module_invoke_all('token_info');
    drupal_alter('token_info', $data);
  }
  return $data;
}

/*
 * Implement hook_registry_files_alter().
 *
 * The files in Token module's /modules directory implement hooks on behalf
 * of other modules. This hook iterates through them and switches the 'owning'
 * module from token to the real one.
 *
 * We loves us drupal_alter().
 */
function token_registry_files_alter(&$files, $modules) {
  $dir = $modules['token']->dir;
  foreach ($modules['token']->info['files'] as $file) {
    $path = split('/', $file);
    $inc_file = array_pop($path);
    $pieces = explode('.', $inc_file, 2);
    if ($pieces[1] == 'tokens.inc') {
      $files["$dir/$file"]['module'] = $pieces[0];
    }
  }
}
